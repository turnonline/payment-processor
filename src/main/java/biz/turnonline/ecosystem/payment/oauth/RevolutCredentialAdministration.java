package biz.turnonline.ecosystem.payment.oauth;

import biz.turnonline.ecosystem.revolut.business.oauth.RevolutCredential;
import com.google.api.gax.rpc.NotFoundException;
import com.google.appengine.api.utils.SystemProperty;
import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionRequest;
import com.google.cloud.secretmanager.v1beta1.AccessSecretVersionResponse;
import com.google.cloud.secretmanager.v1beta1.AddSecretVersionRequest;
import com.google.cloud.secretmanager.v1beta1.CreateSecretRequest;
import com.google.cloud.secretmanager.v1beta1.ProjectName;
import com.google.cloud.secretmanager.v1beta1.Replication;
import com.google.cloud.secretmanager.v1beta1.Secret;
import com.google.cloud.secretmanager.v1beta1.SecretManagerServiceClient;
import com.google.cloud.secretmanager.v1beta1.SecretName;
import com.google.cloud.secretmanager.v1beta1.SecretPayload;
import com.google.cloud.secretmanager.v1beta1.SecretVersion;
import com.google.cloud.secretmanager.v1beta1.SecretVersionName;
import com.google.common.annotations.VisibleForTesting;
import com.google.protobuf.ByteString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.googlecode.objectify.ObjectifyService.ofy;

/**
 * Administration all of the Revolut credential in a secure manner.
 * {@link #ISSUER} is based on environment variable {@code ENDPOINTS_SERVICE_NAME},
 * It's a domain at which microservice is running (design concept).
 * <p>
 * Implementation handles only single certificate. Revolut user is being required to do following steps:
 * <ul>
 *     <li>Upload X509 public key to Revolut Settings</li>
 *     <li>Authorize access to Business Revolut API, will be redirected to cert redirect URI</li>
 *     <li>Get Client ID generated by Revolut (Settings) and update microservice records accordingly</li>
 *     <li>Upload private key to Google Secret Manager under the secret name
 *     {@link RevolutCertDetails#PRIVATE_KEY_NAME}</li>
 *     <li>Make sure default service account that access Google Secret Manager has the 'Secret Manager Admin' role</li>
 * </ul>
 * Now Revolut is ready to be accessed via Business API.
 *
 * @author <a href="mailto:medvegy@turnonline.biz">Aurel Medvegy</a>
 */
@Singleton
public class RevolutCredentialAdministration
        implements RevolutCredential.Certificate, RevolutCredential.Storage
{
    static final String REFRESH_TOKEN_NAME = "Revolut_refresh_token";

    private static final Logger LOGGER = LoggerFactory.getLogger( RevolutCredentialAdministration.class );

    private static final String SECRET_CACHE_KEY = "Revolut_private_cache_key";

    private static final String CLIENT_ID_CACHE_KEY = "Revolut_client_id_cache_key";

    private final String ISSUER;

    /**
     * The GCP identification. It must be the project where the microservice is running
     * in order to connect to the Secret Manager within the same project.
     */
    private final String PROJECT_ID;

    private final Map<String, Object> cache;

    public RevolutCredentialAdministration()
    {
        String serviceNameKey = "ENDPOINTS_SERVICE_NAME";
        String error = "Environment variable " + serviceNameKey + " is null, it's mandatory";

        ISSUER = checkNotNull( System.getenv( serviceNameKey ), error );
        PROJECT_ID = SystemProperty.applicationId.get();
        cache = new ConcurrentHashMap<>();
    }

    public void storeClientId( @Nonnull String clientId )
    {
        String error = "Client ID can't be null";
        ofy().transact( () -> get().setClientId( checkNotNull( clientId, error ) ).save() );
        cache.clear();
    }

    public void storeCode( @Nonnull String code )
    {
        String error = "Authorisation code can't be null";
        ofy().transact( () -> get().setCode( checkNotNull( code, error ) ).save() );
        cache.clear();
    }

    @Override
    public String clientId()
    {
        String clientId = ( String ) cache.get( CLIENT_ID_CACHE_KEY );
        if ( clientId == null )
        {
            clientId = get().getClientId();
            cache.put( CLIENT_ID_CACHE_KEY, clientId );
        }
        return clientId;
    }

    @Override
    public String issuer()
    {
        return ISSUER;
    }

    @Override
    public String getCode( @Nonnull String clientId )
    {
        checkNotNull( clientId, "Client ID can't be null" );
        return get().getCode();
    }

    @Override
    public String getRefreshToken( @Nonnull String clientId )
    {
        checkNotNull( clientId, "Client ID can't be null" );

        String token = ( String ) cache.get( REFRESH_TOKEN_NAME );
        if ( token == null )
        {
            try ( SecretManagerServiceClient client = client() )
            {
                token = readRefreshToken( client );
                cache.put( REFRESH_TOKEN_NAME, token );
            }
            catch ( Exception e )
            {
                LOGGER.error( "Reading refresh token from Secret Manager has failed, Client ID " + clientId, e );
                return null;
            }
        }

        return token;
    }

    @Override
    public void store( @Nonnull String clientId, @Nonnull String token )
    {
        checkNotNull( clientId, "Client ID can't be null" );
        checkNotNull( token, "Refresh token can't be null" );

        cache.clear();
        // Delete already consumed authorisation code
        ofy().transact( () -> get().setCode( null ).save() );

        try ( SecretManagerServiceClient client = client() )
        {
            try
            {
                addRefreshToken( client, token );
            }
            catch ( NotFoundException e )
            {
                createRefreshTokenSecret( client );
                addRefreshToken( client, token );
            }
        }
        catch ( Exception e )
        {
            LOGGER.error( "Adding refresh token in to Secret Manager has failed, Client ID " + clientId, e );
            return;
        }

        cache.put( REFRESH_TOKEN_NAME, token );
    }

    @Override
    public byte[] getSecretKey( @Nonnull String clientId )
    {
        checkNotNull( clientId, "Client ID can't be null" );

        byte[] key = ( byte[] ) cache.get( SECRET_CACHE_KEY );
        if ( key == null )
        {
            try ( SecretManagerServiceClient client = client() )
            {
                key = readSecretKey( client, get().getKeyName() );
                cache.put( SECRET_CACHE_KEY, key );
            }
            catch ( Exception e )
            {
                LOGGER.error( "Reading private key from Secret Manager has failed, Client ID " + clientId, e );
                return null;
            }
        }

        return key;
    }

    /**
     * Returns Revolut certificate details entity.
     *
     * @return the certificate details
     */
    @VisibleForTesting
    RevolutCertDetails get()
    {
        RevolutCertDetails details = ofy().load().type( RevolutCertDetails.class ).id( ISSUER ).now();
        if ( details == null )
        {
            details = new RevolutCertDetails();
            details.setId( ISSUER );
            details.save();
        }

        return details;
    }

    private SecretManagerServiceClient client() throws IOException
    {
        return SecretManagerServiceClient.create();
    }

    /**
     * Creates a secret metadata for the refresh token.
     */
    @VisibleForTesting
    void createRefreshTokenSecret( SecretManagerServiceClient client )
    {
        ProjectName parent = ProjectName.of( PROJECT_ID );
        Secret secret = Secret.newBuilder().setReplication( Replication.newBuilder()
                .setAutomatic( Replication.Automatic.newBuilder().build() )
                .build() )
                .build();

        CreateSecretRequest request =
                CreateSecretRequest.newBuilder()
                        .setParent( parent.toString() )
                        .setSecretId( REFRESH_TOKEN_NAME )
                        .setSecret( secret )
                        .build();

        // calling the remote secret manager service
        Secret createdSecret = client.createSecret( request );
        LOGGER.info( "Refresh token secret has been created: " + createdSecret.getName() );
    }

    /**
     * Adds a new version of refresh token to the existing secret, version of the secret will be increased.
     *
     * @param refreshToken the refresh token to be added
     */
    @VisibleForTesting
    void addRefreshToken( SecretManagerServiceClient client, String refreshToken )
    {
        SecretName name = SecretName.of( PROJECT_ID, REFRESH_TOKEN_NAME );

        // Secret payload.
        SecretPayload payload = SecretPayload.newBuilder()
                .setData( ByteString.copyFromUtf8( refreshToken ) )
                .build();

        AddSecretVersionRequest request = AddSecretVersionRequest.newBuilder()
                .setParent( name.toString() )
                .setPayload( payload )
                .build();

        // calling the remote secret manager service
        SecretVersion version = client.addSecretVersion( request );
        LOGGER.info( "Added refresh token version: " + version.getName() );
    }

    /**
     * Returns the latest refresh token from secret manager.
     *
     * @return the latest refresh token
     */
    @VisibleForTesting
    String readRefreshToken( SecretManagerServiceClient client )
    {
        SecretVersionName name = SecretVersionName.of( PROJECT_ID, REFRESH_TOKEN_NAME, "latest" );

        AccessSecretVersionRequest request;
        request = AccessSecretVersionRequest.newBuilder()
                .setName( name.toString() )
                .build();

        // calling the remote secret manager service
        AccessSecretVersionResponse response = client.accessSecretVersion( request );
        return response.getPayload().getData().toStringUtf8();
    }

    /**
     * Returns the latest private key from secret manager.
     *
     * @return the latest private key
     */
    @VisibleForTesting
    byte[] readSecretKey( SecretManagerServiceClient client, String secretId )
    {
        SecretVersionName name = SecretVersionName.of( PROJECT_ID, secretId, "latest" );

        AccessSecretVersionRequest request;
        request = AccessSecretVersionRequest.newBuilder()
                .setName( name.toString() )
                .build();

        // calling the remote secret manager service
        AccessSecretVersionResponse response = client.accessSecretVersion( request );
        return response.getPayload().getData().toByteArray();
    }
}
